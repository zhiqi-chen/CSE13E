/* 
 * File:   Negotiation.c
 * Author: Zhiqi Chen (zchen287@ucsc.edu)
 *
 * Created on Jun 2, 2021, 20:50 AM
 */

// **** Include libraries here ****
// Standard libraries
#include <string.h>
#include <stdio.h>

//CSE13E Support Library
#include "BOARD.h"

// User libraries
#include "Negotiation.h"

/**
 * This function implements a one-way hash.  It maps its input, A, 
 * into an image, #a, in a way that is hard to reverse, but easy 
 * to reproduce.
 * @param secret        //A number that a challenger commits to
 * @return hash         //the hashed value of the secret commitment.
 *
 * This function implements the "Beef Hash," a variant of a Rabin hash.
 * The result is ((the square of the input) modulo the constant key 0xBEEF).
 * So, for example, 
 * 
 * NegotiationHash(3) == 9
 * NegotiationHash(12345) == 43182
 */
NegotiationData NegotiationHash(NegotiationData secret) {
    // cast what is being passed in and saving it in a secret_t
    // 0xFFFF * 2 = 0xFFFE0001 // 8 * 4 =32
    // (the square of the input) modulo the constant key 0xBEEF
    // return cast as a NegotiationData variable
    
    // use uint64 secret_t = secret
    uint64_t secret_t = secret;
    // calculate hash secret_t * secret_t
    uint64_t hash = secret_t * secret_t;
    // mod the hash
    hash = hash % PUBLIC_KEY;
    // cast it before return
    hash = hash ^ (hash >> 32);
    hash = hash ^ (hash >> 16);
    return hash;
}

/**
 * Detect cheating.  An accepting agent will receive both a commitment hash
 * and a secret number from the challenging agent.  This function
 * verifies that the secret and the commitment hash agree, hopefully
 * detecting cheating by the challenging agent.
 *
 * @param secret        //the previously secret number that the challenging agent has revealed
 * @param commitment    //the hash of the secret number
 * @return TRUE if the commitment validates the revealed secret, FALSE otherwise
 */
int NegotiationVerify(NegotiationData secret, NegotiationData commitment) {
    // check if processing secret is equal to the commitment
    // if yes, return TRUE, if not, FALSE
    if (NegotiationHash(secret) == commitment) {
        return TRUE;
    }
    else {
        return FALSE;
    } 
}

/**
 * The coin-flip protocol uses random numbers generated by both
 * agents to determine the outcome of the coin flip.
 *
 * The parity of a bitstring is 1 if there are an odd number of one bits,
 *   and 0 otherwise.
 * So, for example, the number 0b01101011 has 5 ones.  If the parity of
 * A XOR B is 1, then the outcome is HEADS.  Otherwise, the outcome is TAILS.
 */
NegotiationOutcome NegotiateCoinFlip(NegotiationData A, NegotiationData B) {
    // coin = A XOR B
    // check each of coin if even or odd... odd parity is HEADS, even parity is TAILS
    
    // find the XOR
    NegotiationData coin = A ^ B;
    // set a local variable to 0 and do the count
    int count = 0;
    // flip the coin and add to the count   
    // coin = coin & (coin - 1) count++
    for (count = 0; count < coin; count++) {
        coin = coin & (coin - 1);
    }
    // check if the count % 2 is 1
    //   if it is, return HEADS
    //   otherwise, return TAILS
    if (count % 2 == 1) {
        return HEADS;
    }
    else {
        return TAILS;
    }
}


/**
 * Extra credit: 
 * Use either or both of these two functions if you want to generate a "cheating" agent.  
 *
 * To get extra credit, define these functions 
 * and use these functions in agent.c to generate A and/or B
 * 
 * Your agent only needs to be able to cheat at one role for extra credit.  They must result in 
 * your agent going first more than 75% of the time in that role when
 * competing against a fair agent (that is, an agent that uses purely random A and B).
 *
 * You must state that you did this at the top of your README, and describe your 
 * strategy thoroughly.
 */

